#' Load `bcbio` Single-Cell RNA-Seq Run
#'
#' @rdname loadRun
#' @name loadRun
#'
#' @details
#' - **cellranger**: Read [10x Genomics
#'   Chromium](https://www.10xgenomics.com/software/) cell counts from
#'   `barcodes.tsv`, `genes.tsv`, and `matrix.mtx` files.
#'
#' @note When working in RStudio, we recommend connecting to the bcbio-nextgen
#'   run directory as a remote connection over
#'   [sshfs](https://github.com/osxfuse/osxfuse/wiki/SSHFS).
#'
#' @param object Path to final upload directory. This path is set when running
#'   `bcbio_nextgen -w template`.
#' @param sampleMetadataFile **Required**. Sample barcode metadata file.
#' @param wellMetadataFile *Optional*. Well identifier metadata file.
#' @param interestingGroups Character vector of interesting groups. First entry
#'   is used for plot colors during quality control (QC) analysis. Entire vector
#'   is used for PCA and heatmap QC functions.
#' @param tx2gene tx2gene [data.frame], required when using a custom
#'   transcriptome FASTA file. This argument will be removed in a future update.
#' @param ... Additional arguments, passed as metadata.
#'
#' @return [bcbioSCDataSet].
NULL



# Methods ====
#' @rdname loadRun
#' @export
setMethod("loadRun", "character", function(
    object = "final",
    sampleMetadataFile,
    wellMetadataFile = NULL,
    interestingGroups = "sampleName",
    tx2gene = NULL,
    ...) {
    uploadDir <- object
    if (!dir.exists(uploadDir)) {
        stop("Upload directory missing")
    }


    # Initial run setup ====
    uploadDir <- normalizePath(uploadDir)
    if (!dir.exists(uploadDir)) {
        stop("Final upload directory does not exist")
    }
    pipeline <- .detectPipeline(uploadDir)
    sampleDirs <- .sampleDirs(uploadDir, pipeline = pipeline)


    # Sample metadata ====
    sampleMetadataFile <- normalizePath(sampleMetadataFile)
    sampleMetadata <- .readSampleMetadataFile(
        sampleMetadataFile, sampleDirs, pipeline)

    # Check to ensure interesting groups are defined
    if (!all(interestingGroups %in% colnames(sampleMetadata))) {
        stop("Interesting groups missing in sample metadata")
    }

    # Check to see if a subset of samples is requested via the metadata file.
    # This matches by the reverse complement sequence of the index barcode.
    if (nrow(sampleMetadata) < length(sampleDirs)) {
        message("Loading a subset of samples, defined by the metadata file")
        allSamples <- FALSE
        sampleDirs <- sampleDirs %>%
            .[names(sampleDirs) %in% rownames(sampleMetadata)]
        message(paste(length(sampleDirs), "samples matched by metadata"))
    } else {
        allSamples <- TRUE
    }


    # Pipeline-specific support prior to count loading ====
    if (pipeline == "bcbio") {
        # Project directory ----
        projectDir <- dir(uploadDir,
                           pattern = projectDirPattern,
                           full.names = FALSE,
                           recursive = FALSE)
        if (length(projectDir) != 1L) {
            stop("Uncertain about project directory location")
        }
        message(projectDir)
        match <- str_match(projectDir, projectDirPattern)
        runDate <- match[[2L]] %>% as.Date
        template <- match[[3L]]
        projectDir <- file.path(uploadDir, projectDir)

        # Log files ----
        message("Reading log files")
        bcbioLog <- .logFile(
            file.path(projectDir, "bcbio-nextgen.log"))
        bcbioCommandsLog <- .logFile(
            file.path(projectDir, "bcbio-nextgen-commands.log"))

        # Cellular barcode cutoff ----
        cbCutoffPattern <- "--cb_cutoff (\\d+)"
        cbCutoff <- str_match(bcbioCommandsLog, cbCutoffPattern) %>%
            .[, 2L] %>%
            na.omit %>%
            unique %>%
            as.numeric

        # Data versions and programs ----
        dataVersions <- .dataVersions(projectDir)
        programs <- .programs(projectDir)
        if (!is.null(dataVersions)) {
            genomeBuild <- dataVersions %>%
                filter(.data[["resource"]] == "transcripts") %>%
                pull("genome")
        } else {
            # Data versions aren't saved when using a custom FASTA
            # Remove this in a future update
            genomePattern <- "work/rapmap/[^/]+/quasiindex/([^/]+)/"
            if (any(str_detect(bcbioCommandsLog, genomePattern))) {
                genomeBuild <- str_match(bcbioCommandsLog,
                                          genomePattern) %>%
                    .[, 2L] %>%
                    na.omit %>%
                    unique
            } else {
                stop("Genome detection from bcbio commands failed")
            }
        }
        if (length(genomeBuild) > 1L) {
            stop("Multiple genomes detected -- not supported")
        }

        # Molecular barcode (UMI) type ----
        umiPattern <- "/umis/([a-z0-9\\-]+)\\.json"
        if (any(str_detect(bcbioCommandsLog, umiPattern))) {
            umiType <- str_match(bcbioCommandsLog,
                                  umiPattern) %>%
                .[, 2L] %>%
                na.omit %>%
                unique %>%
                str_replace("-transform", "")
        } else {
            stop("Failed to detect UMI type from JSON file")
        }

        # Well metadata ----
        if (!is.null(wellMetadataFile)) {
            wellMetadataFile <- normalizePath(wellMetadataFile)
            wellMetadata <- readFileByExtension(wellMetadataFile)
        } else {
            wellMetadata <- NULL
        }

        # tx2gene ----
        if (is.null(tx2gene)) {
            tx2gene <- tx2gene(genomeBuild)
        }

        # Cellular barcodes ----
        cellularBarcodes <- .cbList(sampleDirs)
    } else if (pipeline == "cellranger") {
        # Get genome build from `sampleDirs`
        genomeBuild <- basename(sampleDirs) %>% unique
        if (length(genomeBuild) > 1L) {
            stop("Multiple genomes detected -- not supported")
        }
        umiType <- "chromium"
    }

    message(paste("UMI type:", umiType))


    # Row data ====
    annotable <- annotable(genomeBuild)


    # Read counts into sparse matrix ====
    message("Reading counts")
    sparseList <- pblapply(seq_along(sampleDirs), function(a) {
        sparseCounts <- .readSparseCounts(sampleDirs[a], pipeline = pipeline)
        if (pipeline == "bcbio") {
            # Transcript-level to gene-level counts
            sparseCounts <-
                .sparseCountsTx2Gene(sparseCounts, tx2gene)
        }
        # Pre-filter using cellular barcode summary metrics
        metrics <- calculateMetrics(sparseCounts, annotable)
        sparseCounts[, rownames(metrics)]
    }) %>%
        set_names(names(sampleDirs))
    sparseCounts <- do.call(Matrix::cBind, sparseList)


    # Column data ====
    metrics <- calculateMetrics(sparseCounts, annotable)
    if (pipeline == "bcbio") {
        # Add reads per cellular barcode to metrics
        cbTbl <- .bindCB(cellularBarcodes) %>%
            mutate(cellularBarcode = NULL,
                   sampleID = NULL)
        metrics <- metrics %>%
            as.data.frame %>%
            rownames_to_column %>%
            left_join(cbTbl, by = "rowname") %>%
            tidy_select("nCount", everything()) %>%
            column_to_rownames %>%
            as.matrix
    }


    # Metadata ====
    if (umiType == "indrop") {
        multiplexedFASTQ <- TRUE
    } else {
        multiplexedFASTQ <- FALSE
    }
    metadata <- SimpleList(
        version = packageVersion("bcbioSinglecell"),
        pipeline = pipeline,
        uploadDir = uploadDir,
        sampleDirs = sampleDirs,
        sampleMetadataFile = sampleMetadataFile,
        sampleMetadata = sampleMetadata,
        interestingGroups = interestingGroups,
        genomeBuild = genomeBuild,
        annotable = annotable,
        ensemblVersion = ensemblVersion(),
        umiType = umiType,
        allSamples = allSamples,
        multiplexedFASTQ = multiplexedFASTQ)
    if (pipeline == "bcbio") {
        bcbioMetadata <- SimpleList(
            projectDir = projectDir,
            wellMetadataFile = wellMetadataFile,
            wellMetadata = wellMetadata,
            template = template,
            runDate = runDate,
            tx2gene = tx2gene,
            dataVersions = dataVersions,
            programs = programs,
            bcbioLog = bcbioLog,
            bcbioCommandsLog = bcbioCommandsLog,
            cbCutoff = cbCutoff)
        metadata <- c(metadata, bcbioMetadata)
    }
    # Add user-defined custom metadata, if specified
    dots <- list(...)
    if (length(dots) > 0L) {
        metadata <- c(metadata, dots)
    }


    # Return ====
    se <- packageSE(
        sparseCounts,
        colData = metrics,
        rowData = annotable,
        metadata = metadata)
    bcb <- new("bcbioSCDataSet", se)
    if (pipeline == "bcbio") {
        bcbio(bcb, "cellularBarcodes") <- cellularBarcodes
    }
    bcb
})

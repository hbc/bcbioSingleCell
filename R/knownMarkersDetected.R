#' Known Markers Detected
#'
#' @note Both the `all` and `known` objects must contain Ensembl gene
#'   identifiers in the `geneID` column. We must avoid any matching operations
#'   based on the gene names, since these change often and can mismatch
#'   easily.
#'
#' @family Clustering Functions
#' @author Michael Steinbaugh
#'
#' @inheritParams general
#' @param all `grouped_df`, grouped by `cluster`. All markers `data.frame`,
#'   generated by [Seurat::FindAllMarkers()] return and sanitized with
#'   [sanitizeMarkers()]. Note that an unmodified Seurat markers `data.frame`
#'   will error here by design, since it doesn't consistently contain Ensembl
#'   gene identifiers.
#' @param known `grouped_df`, grouped by `cellType` column. Known markers
#'   `data.frame` imported by [readCellTypeMarkers()] or pulled from internal
#'   [cell_cycle_markers] data.
#' @param alpha `scalar numeric`. Alpha cutoff (adjusted P value; false
#'   discovery rate).
#' @param filterPromiscuous `boolean`. Remove genes with poor specificity, that
#'   are present in as many clusters as defined by `promiscuousCutoff`.
#' @param promiscuousCutoff `scalar integer`. Minimum number of clusters
#'   required to consider a gene marker promiscuous.
#'
#' @return `grouped_df`, grouped by "`cellType`" column.
#' @export
#'
#' @examples
#' # grouped_df ====
#' x <- knownMarkersDetected(
#'     all = all_markers_small,
#'     known = cell_type_markers[["homoSapiens"]]
#' )
#' head(x)
knownMarkersDetected <- function(
    all,
    known,
    alpha = 0.05,
    filterPromiscuous = FALSE,
    promiscuousCutoff = 5L
) {
    stopifnot(.isSanitizedMarkers(all))
    assert_is_tbl_df(all)
    assert_is_tbl_df(known)
    # Check for `geneID` column in both `all` and `known`
    assert_is_subset("geneID", colnames(all))
    assert_is_subset("geneID", colnames(known))
    # Check for `geneID` overlap; avoid accidental organism mismatch
    assert_are_intersecting_sets(known[["geneID"]], all[["geneID"]])
    assert_is_a_number(alpha)
    assert_all_are_in_left_open_range(x = alpha, lower = 0L, upper = 1L)
    assert_is_a_bool(filterPromiscuous)
    # Check for valid promiscuous cutoff
    assertIsAnImplicitInteger(promiscuousCutoff)
    assert_all_are_in_left_open_range(promiscuousCutoff, 1L)
    # Group by cell type and arrange by P value
    markers <- all %>%
        ungroup() %>%
        # Apply alpha cutoff, before adding cell type annotations
        filter(!!sym("padj") < !!alpha) %>%
        left_join(known[, c("cellType", "geneID")], by = "geneID") %>%
        select(
            !!!syms(c("cellType", "cluster", "geneID", "geneName")),
            everything()
        ) %>%
        mutate_at(c("cellType", "cluster"), as.factor) %>%
        filter(!is.na(!!sym("cellType"))) %>%
        group_by(!!sym("cellType")) %>%
        arrange(!!sym("padj"), .by_group = TRUE)
    if (isTRUE(filterPromiscuous)) {
        # Filter out promiscuous markers present in multiple clusters
        promiscuous <- markers %>%
            ungroup() %>%
            group_by(!!!syms(c("cellType", "geneID", "geneName"))) %>%
            summarize(n = n()) %>%
            filter(!!sym("n") >= !!promiscuousCutoff) %>%
            pull("geneID")
        if (length(promiscuous)) {
            message(paste(
                "Promiscuous markers:", toString(promiscuous)
            ))
            markers <- filter(markers, !!sym("geneID") %in% !!!promiscuous)
        }
    }
    markers
}
